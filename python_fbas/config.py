from dataclasses import dataclass, replace, fields
from typing import Literal, Optional, Dict, Any
from contextlib import contextmanager
import os
import yaml
import logging

# ---------------------------------------------------------------------------#
# Immutable configuration object
# ---------------------------------------------------------------------------#
@dataclass(frozen=True, slots=True)
class Config:
    stellar_data_url: str = "https://radar.withobsrvr.com/api/v1/node"
    sat_solver: str = "cryptominisat5"
    card_encoding: Literal["naive", "totalizer"] = "totalizer"
    max_sat_algo: Literal["LSU", "RC2"] = "LSU"
    output: Optional[str] = None
    group_by: Optional[str] = None
    validator_display: Literal["id", "name", "both"] = "both"


_cfg: Config = Config()           # single authoritative instance


def get() -> Config:
    """Return current configuration (read-only)."""
    return _cfg


def update(**kwargs) -> None:
    """Atomically replace the configuration with a modified copy."""
    global _cfg
    _cfg = replace(_cfg, **kwargs)


def load_from_file(config_path: str) -> Dict[str, Any]:
    """Load configuration from a YAML file."""
    if not os.path.exists(config_path):
        raise FileNotFoundError(f"Config file not found: {config_path}")
    
    try:
        with open(config_path, 'r', encoding='utf-8') as f:
            config_data = yaml.safe_load(f) or {}
        logging.info(f"Loaded configuration from {config_path}")
        return config_data
    except yaml.YAMLError as e:
        raise ValueError(f"Invalid YAML in config file {config_path}: {e}")
    except Exception as e:
        raise RuntimeError(f"Error reading config file {config_path}: {e}")


def to_yaml() -> str:
    """
    Export current configuration as YAML string.
    Returns valid YAML that can be saved as a config file.
    """
    cfg = get()
    
    # Convert dataclass to dict, excluding None values for cleaner output
    config_dict = {}
    for field in fields(cfg):
        value = getattr(cfg, field.name)
        if value is not None:
            config_dict[field.name] = value
    
    # Generate YAML with comments for better user experience
    yaml_lines = [
        "# python-fbas configuration file",
        "# This file was generated by 'python-fbas show-config'",
        "# You can edit these values and save as python-fbas.cfg",
        "",
    ]
    
    # Add sections with comments
    sections = {
        "# Data source": ["stellar_data_url"],
        "# Solver settings": ["sat_solver", "card_encoding", "max_sat_algo"],
        "# Output settings": ["validator_display", "output"],
        "# Optional settings": ["group_by"]
    }
    
    for section_comment, keys in sections.items():
        section_has_values = any(key in config_dict for key in keys)
        if section_has_values:
            yaml_lines.append(section_comment)
            for key in keys:
                if key in config_dict:
                    # Use yaml.dump to properly escape values, but clean up output
                    value_yaml = yaml.dump(config_dict[key], default_flow_style=False).strip()
                    # Remove the trailing '...' that yaml.dump adds
                    if value_yaml.endswith('...'):
                        value_yaml = value_yaml[:-3].strip()
                    yaml_lines.append(f"{key}: {value_yaml}")
            yaml_lines.append("")
    
    return "\n".join(yaml_lines)


def load_config_file(config_path: Optional[str] = None) -> None:
    """
    Load configuration from file with precedence:
    1. Explicit config_path if provided
    2. python-fbas.cfg in current directory
    3. No config file (use defaults)
    """
    config_data = {}
    
    # Try explicit config path first
    if config_path:
        config_data = load_from_file(config_path)
    else:
        # Try default config file in current directory
        default_config = "python-fbas.cfg"
        if os.path.exists(default_config):
            config_data = load_from_file(default_config)
        else:
            logging.debug("No config file found, using defaults")
            return
    
    # Validate config keys against Config dataclass fields
    valid_keys = {f.name for f in fields(Config)}
    invalid_keys = set(config_data.keys()) - valid_keys
    if invalid_keys:
        logging.warning(f"Unknown config keys ignored: {invalid_keys}")
        config_data = {k: v for k, v in config_data.items() if k in valid_keys}
    
    # Validate literal types
    if 'card_encoding' in config_data and config_data['card_encoding'] not in ['naive', 'totalizer']:
        raise ValueError(f"Invalid card_encoding in config file: {config_data['card_encoding']}")
    
    if 'max_sat_algo' in config_data and config_data['max_sat_algo'] not in ['LSU', 'RC2']:
        raise ValueError(f"Invalid max_sat_algo in config file: {config_data['max_sat_algo']}")
    
    if 'validator_display' in config_data and config_data['validator_display'] not in ['id', 'name', 'both']:
        raise ValueError(f"Invalid validator_display in config file: {config_data['validator_display']}")
    
    # Update configuration
    update(**config_data)


@contextmanager
def temporary_config(**kwargs):
    """Temporarily override configuration values inside a *with* block."""
    old = _cfg
    update(**kwargs)
    try:
        yield
    finally:
        update(**{f.name: getattr(old, f.name) for f in fields(old)})
